{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = 'http://localhost:8000'; // Changed to use the same port as sync API\n\nclass SubtitleGeneratorAPI {\n  constructor() {\n    this.baseURL = GENERATOR_API_BASE_URL;\n  }\n\n  // Get available Whisper models\n  async getAvailableModels() {\n    const response = await axios.get(`${this.baseURL}/models/`);\n    return response.data;\n  }\n\n  // Upload video file for subtitle generation\n  async uploadVideo(videoFile, onProgress = null) {\n    const formData = new FormData();\n    formData.append('video_file', videoFile);\n    const config = {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    };\n    if (onProgress) {\n      config.onUploadProgress = progressEvent => {\n        const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n        onProgress(percentCompleted);\n      };\n    }\n    const response = await axios.post(`${this.baseURL}/upload-video/`, formData, config);\n    return response.data;\n  }\n\n  // Start subtitle generation process\n  async startGeneration(videoFilename, subtitleFormat = 'srt', whisperModel = 'base', outputFilename = null) {\n    const data = {\n      video_filename: videoFilename,\n      subtitle_format: subtitleFormat,\n      whisper_model: whisperModel\n    };\n    if (outputFilename) {\n      data.output_filename = outputFilename;\n    }\n    const response = await axios.post(`${this.baseURL}/generate/`, data);\n    return response.data;\n  }\n\n  // Get task status\n  async getTaskStatus(taskId) {\n    const response = await axios.get(`${this.baseURL}/status/${taskId}`);\n    return response.data;\n  }\n\n  // Get task result\n  async getTaskResult(taskId) {\n    const response = await axios.get(`${this.baseURL}/result/${taskId}`);\n    return response.data;\n  }\n\n  // Download file\n  async downloadFile(filename) {\n    const response = await axios.get(`${this.baseURL}/download/${filename}`, {\n      responseType: 'blob'\n    });\n    return response.data;\n  }\n\n  // Get file content as text (for preview)\n  async getFileContent(filename) {\n    const response = await axios.get(`${this.baseURL}/download/${filename}`);\n    return response.data;\n  }\n\n  // List all files\n  async listFiles() {\n    const response = await axios.get(`${this.baseURL}/files/`);\n    return response.data;\n  }\n\n  // Delete file\n  async deleteFile(filename, fileType = 'upload') {\n    const response = await axios.delete(`${this.baseURL}/files/${filename}`, {\n      params: {\n        file_type: fileType\n      }\n    });\n    return response.data;\n  }\n\n  // Cleanup all files\n  async cleanup() {\n    const response = await axios.delete(`${this.baseURL}/cleanup/`);\n    return response.data;\n  }\n\n  // Health check\n  async healthCheck() {\n    try {\n      const response = await axios.get(`${this.baseURL}/health/`);\n      return response.data;\n    } catch (error) {\n      throw new Error('Generator API server is not available');\n    }\n  }\n\n  // Poll task until completion\n  async pollTaskUntilComplete(taskId, pollInterval = 3000, maxAttempts = 100) {\n    let attempts = 0;\n    while (attempts < maxAttempts) {\n      const status = await this.getTaskStatus(taskId);\n      if (status.status === 'completed' || status.status === 'failed') {\n        return status;\n      }\n      attempts++;\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n    }\n    throw new Error('Task polling timeout');\n  }\n}\nexport default SubtitleGeneratorAPI;","map":{"version":3,"names":["axios","API_BASE_URL","SubtitleGeneratorAPI","constructor","baseURL","GENERATOR_API_BASE_URL","getAvailableModels","response","get","data","uploadVideo","videoFile","onProgress","formData","FormData","append","config","headers","onUploadProgress","progressEvent","percentCompleted","Math","round","loaded","total","post","startGeneration","videoFilename","subtitleFormat","whisperModel","outputFilename","video_filename","subtitle_format","whisper_model","output_filename","getTaskStatus","taskId","getTaskResult","downloadFile","filename","responseType","getFileContent","listFiles","deleteFile","fileType","delete","params","file_type","cleanup","healthCheck","error","Error","pollTaskUntilComplete","pollInterval","maxAttempts","attempts","status","Promise","resolve","setTimeout"],"sources":["D:/38029/Subtitle Sync/UI/frontend/src/generatorApi.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_BASE_URL = 'http://localhost:8000'; // Changed to use the same port as sync API\r\n\r\nclass SubtitleGeneratorAPI {\r\n  constructor() {\r\n    this.baseURL = GENERATOR_API_BASE_URL;\r\n  }\r\n\r\n  // Get available Whisper models\r\n  async getAvailableModels() {\r\n    const response = await axios.get(`${this.baseURL}/models/`);\r\n    return response.data;\r\n  }\r\n\r\n  // Upload video file for subtitle generation\r\n  async uploadVideo(videoFile, onProgress = null) {\r\n    const formData = new FormData();\r\n    formData.append('video_file', videoFile);\r\n\r\n    const config = {\r\n      headers: {\r\n        'Content-Type': 'multipart/form-data',\r\n      },\r\n    };\r\n\r\n    if (onProgress) {\r\n      config.onUploadProgress = (progressEvent) => {\r\n        const percentCompleted = Math.round(\r\n          (progressEvent.loaded * 100) / progressEvent.total\r\n        );\r\n        onProgress(percentCompleted);\r\n      };\r\n    }\r\n\r\n    const response = await axios.post(`${this.baseURL}/upload-video/`, formData, config);\r\n    return response.data;\r\n  }\r\n\r\n  // Start subtitle generation process\r\n  async startGeneration(videoFilename, subtitleFormat = 'srt', whisperModel = 'base', outputFilename = null) {\r\n    const data = {\r\n      video_filename: videoFilename,\r\n      subtitle_format: subtitleFormat,\r\n      whisper_model: whisperModel,\r\n    };\r\n\r\n    if (outputFilename) {\r\n      data.output_filename = outputFilename;\r\n    }\r\n\r\n    const response = await axios.post(`${this.baseURL}/generate/`, data);\r\n    return response.data;\r\n  }\r\n\r\n  // Get task status\r\n  async getTaskStatus(taskId) {\r\n    const response = await axios.get(`${this.baseURL}/status/${taskId}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Get task result\r\n  async getTaskResult(taskId) {\r\n    const response = await axios.get(`${this.baseURL}/result/${taskId}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Download file\r\n  async downloadFile(filename) {\r\n    const response = await axios.get(`${this.baseURL}/download/${filename}`, {\r\n      responseType: 'blob',\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Get file content as text (for preview)\r\n  async getFileContent(filename) {\r\n    const response = await axios.get(`${this.baseURL}/download/${filename}`);\r\n    return response.data;\r\n  }\r\n\r\n  // List all files\r\n  async listFiles() {\r\n    const response = await axios.get(`${this.baseURL}/files/`);\r\n    return response.data;\r\n  }\r\n\r\n  // Delete file\r\n  async deleteFile(filename, fileType = 'upload') {\r\n    const response = await axios.delete(`${this.baseURL}/files/${filename}`, {\r\n      params: { file_type: fileType }\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Cleanup all files\r\n  async cleanup() {\r\n    const response = await axios.delete(`${this.baseURL}/cleanup/`);\r\n    return response.data;\r\n  }\r\n\r\n  // Health check\r\n  async healthCheck() {\r\n    try {\r\n      const response = await axios.get(`${this.baseURL}/health/`);\r\n      return response.data;\r\n    } catch (error) {\r\n      throw new Error('Generator API server is not available');\r\n    }\r\n  }\r\n\r\n  // Poll task until completion\r\n  async pollTaskUntilComplete(taskId, pollInterval = 3000, maxAttempts = 100) {\r\n    let attempts = 0;\r\n    \r\n    while (attempts < maxAttempts) {\r\n      const status = await this.getTaskStatus(taskId);\r\n      \r\n      if (status.status === 'completed' || status.status === 'failed') {\r\n        return status;\r\n      }\r\n      \r\n      attempts++;\r\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\r\n    }\r\n    \r\n    throw new Error('Task polling timeout');\r\n  }\r\n}\r\n\r\nexport default SubtitleGeneratorAPI;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}