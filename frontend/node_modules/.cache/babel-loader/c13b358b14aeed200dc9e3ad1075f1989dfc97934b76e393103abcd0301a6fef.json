{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = 'http://localhost:8000';\nclass SubtitleSyncAPI {\n  constructor() {\n    this.baseURL = API_BASE_URL;\n  }\n\n  // Upload video and subtitle files\n  async uploadFiles(videoFile, subtitleFile, onProgress = null) {\n    const formData = new FormData();\n    formData.append('video_file', videoFile);\n    formData.append('subtitle_file', subtitleFile);\n    const config = {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    };\n    if (onProgress) {\n      config.onUploadProgress = progressEvent => {\n        const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n        onProgress(percentCompleted);\n      };\n    }\n    const response = await axios.post(`${this.baseURL}/upload-files/`, formData, config);\n    return response.data;\n  }\n\n  // Start synchronization process\n  async startSync(videoFilename, subtitleFilename, outputFilename = null) {\n    const data = {\n      video_filename: videoFilename,\n      subtitle_filename: subtitleFilename\n    };\n    if (outputFilename) {\n      data.output_filename = outputFilename;\n    }\n    const response = await axios.post(`${this.baseURL}/sync/`, data);\n    return response.data;\n  }\n\n  // Get task status\n  async getTaskStatus(taskId) {\n    const response = await axios.get(`${this.baseURL}/status/${taskId}`);\n    return response.data;\n  }\n\n  // Get task result\n  async getTaskResult(taskId) {\n    const response = await axios.get(`${this.baseURL}/result/${taskId}`);\n    return response.data;\n  }\n\n  // Download synchronized subtitle file\n  async downloadFile(filename) {\n    const response = await axios.get(`${this.baseURL}/download/${filename}`, {\n      responseType: 'blob'\n    });\n\n    // Create download link\n    const url = window.URL.createObjectURL(new Blob([response.data]));\n    const link = document.createElement('a');\n    link.href = url;\n    link.setAttribute('download', filename);\n    document.body.appendChild(link);\n    link.click();\n    link.remove();\n    window.URL.revokeObjectURL(url);\n    return true;\n  }\n\n  // List all files\n  async listFiles() {\n    const response = await axios.get(`${this.baseURL}/files/`);\n    return response.data;\n  }\n\n  // Delete a file\n  async deleteFile(filename, fileType = 'upload') {\n    const response = await axios.delete(`${this.baseURL}/files/${filename}`, {\n      params: {\n        file_type: fileType\n      }\n    });\n    return response.data;\n  }\n\n  // Cleanup all files\n  async cleanup() {\n    const response = await axios.delete(`${this.baseURL}/cleanup/`);\n    return response.data;\n  }\n\n  // Health check\n  async healthCheck() {\n    const response = await axios.get(`${this.baseURL}/health/`);\n    return response.data;\n  }\n\n  // Utility method to poll task status until completion\n  async waitForCompletion(taskId, onStatusUpdate = null, pollInterval = 2000) {\n    return new Promise((resolve, reject) => {\n      const poll = async () => {\n        try {\n          const status = await this.getTaskStatus(taskId);\n          if (onStatusUpdate) {\n            onStatusUpdate(status);\n          }\n          if (status.status === 'completed' || status.status === 'failed') {\n            resolve(status);\n          } else {\n            setTimeout(poll, pollInterval);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n      poll();\n    });\n  }\n\n  // Format file size\n  static formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // Format processing time\n  static formatProcessingTime(seconds) {\n    if (seconds < 60) {\n      return `${seconds.toFixed(1)}s`;\n    } else {\n      const minutes = Math.floor(seconds / 60);\n      const remainingSeconds = seconds % 60;\n      return `${minutes}m ${remainingSeconds.toFixed(1)}s`;\n    }\n  }\n}\nexport default SubtitleSyncAPI;","map":{"version":3,"names":["axios","API_BASE_URL","SubtitleSyncAPI","constructor","baseURL","uploadFiles","videoFile","subtitleFile","onProgress","formData","FormData","append","config","headers","onUploadProgress","progressEvent","percentCompleted","Math","round","loaded","total","response","post","data","startSync","videoFilename","subtitleFilename","outputFilename","video_filename","subtitle_filename","output_filename","getTaskStatus","taskId","get","getTaskResult","downloadFile","filename","responseType","url","window","URL","createObjectURL","Blob","link","document","createElement","href","setAttribute","body","appendChild","click","remove","revokeObjectURL","listFiles","deleteFile","fileType","delete","params","file_type","cleanup","healthCheck","waitForCompletion","onStatusUpdate","pollInterval","Promise","resolve","reject","poll","status","setTimeout","error","formatFileSize","bytes","k","sizes","i","floor","log","parseFloat","pow","toFixed","formatProcessingTime","seconds","minutes","remainingSeconds"],"sources":["D:/38029/Subtitle Sync/UI/frontend/src/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_BASE_URL = 'http://localhost:8000';\r\n\r\nclass SubtitleSyncAPI {\r\n  constructor() {\r\n    this.baseURL = API_BASE_URL;\r\n  }\r\n\r\n  // Upload video and subtitle files\r\n  async uploadFiles(videoFile, subtitleFile, onProgress = null) {\r\n    const formData = new FormData();\r\n    formData.append('video_file', videoFile);\r\n    formData.append('subtitle_file', subtitleFile);\r\n\r\n    const config = {\r\n      headers: {\r\n        'Content-Type': 'multipart/form-data',\r\n      },\r\n    };\r\n\r\n    if (onProgress) {\r\n      config.onUploadProgress = (progressEvent) => {\r\n        const percentCompleted = Math.round(\r\n          (progressEvent.loaded * 100) / progressEvent.total\r\n        );\r\n        onProgress(percentCompleted);\r\n      };\r\n    }\r\n\r\n    const response = await axios.post(`${this.baseURL}/upload-files/`, formData, config);\r\n    return response.data;\r\n  }\r\n\r\n  // Start synchronization process\r\n  async startSync(videoFilename, subtitleFilename, outputFilename = null) {\r\n    const data = {\r\n      video_filename: videoFilename,\r\n      subtitle_filename: subtitleFilename,\r\n    };\r\n\r\n    if (outputFilename) {\r\n      data.output_filename = outputFilename;\r\n    }\r\n\r\n    const response = await axios.post(`${this.baseURL}/sync/`, data);\r\n    return response.data;\r\n  }\r\n\r\n  // Get task status\r\n  async getTaskStatus(taskId) {\r\n    const response = await axios.get(`${this.baseURL}/status/${taskId}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Get task result\r\n  async getTaskResult(taskId) {\r\n    const response = await axios.get(`${this.baseURL}/result/${taskId}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Download synchronized subtitle file\r\n  async downloadFile(filename) {\r\n    const response = await axios.get(`${this.baseURL}/download/${filename}`, {\r\n      responseType: 'blob',\r\n    });\r\n    \r\n    // Create download link\r\n    const url = window.URL.createObjectURL(new Blob([response.data]));\r\n    const link = document.createElement('a');\r\n    link.href = url;\r\n    link.setAttribute('download', filename);\r\n    document.body.appendChild(link);\r\n    link.click();\r\n    link.remove();\r\n    window.URL.revokeObjectURL(url);\r\n    \r\n    return true;\r\n  }\r\n\r\n  // List all files\r\n  async listFiles() {\r\n    const response = await axios.get(`${this.baseURL}/files/`);\r\n    return response.data;\r\n  }\r\n\r\n  // Delete a file\r\n  async deleteFile(filename, fileType = 'upload') {\r\n    const response = await axios.delete(`${this.baseURL}/files/${filename}`, {\r\n      params: { file_type: fileType }\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Cleanup all files\r\n  async cleanup() {\r\n    const response = await axios.delete(`${this.baseURL}/cleanup/`);\r\n    return response.data;\r\n  }\r\n\r\n  // Health check\r\n  async healthCheck() {\r\n    const response = await axios.get(`${this.baseURL}/health/`);\r\n    return response.data;\r\n  }\r\n\r\n  // Utility method to poll task status until completion\r\n  async waitForCompletion(taskId, onStatusUpdate = null, pollInterval = 2000) {\r\n    return new Promise((resolve, reject) => {\r\n      const poll = async () => {\r\n        try {\r\n          const status = await this.getTaskStatus(taskId);\r\n          \r\n          if (onStatusUpdate) {\r\n            onStatusUpdate(status);\r\n          }\r\n\r\n          if (status.status === 'completed' || status.status === 'failed') {\r\n            resolve(status);\r\n          } else {\r\n            setTimeout(poll, pollInterval);\r\n          }\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      };\r\n\r\n      poll();\r\n    });\r\n  }\r\n\r\n  // Format file size\r\n  static formatFileSize(bytes) {\r\n    if (bytes === 0) return '0 Bytes';\r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n\r\n  // Format processing time\r\n  static formatProcessingTime(seconds) {\r\n    if (seconds < 60) {\r\n      return `${seconds.toFixed(1)}s`;\r\n    } else {\r\n      const minutes = Math.floor(seconds / 60);\r\n      const remainingSeconds = seconds % 60;\r\n      return `${minutes}m ${remainingSeconds.toFixed(1)}s`;\r\n    }\r\n  }\r\n}\r\n\r\nexport default SubtitleSyncAPI;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}